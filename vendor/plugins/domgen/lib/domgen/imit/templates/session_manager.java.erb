/* DO NOT EDIT: File is auto-generated */
package <%= repository.imit.encoder_package %>;

@javax.annotation.Generated( "Domgen" )
public abstract class <%= repository.imit.session_manager_name %>
  extends org.realityforge.replicant.server.transport.ReplicantSessionManager<<%= repository.imit.qualified_session_name %>>
{
  @javax.inject.Inject
  private <%= repository.imit.qualified_graph_encoder_name %> _encoder;

  @javax.annotation.Nonnull
  protected final <%= repository.imit.qualified_graph_encoder_name %> getEncoder()
  {
    return _encoder;
  }

  @SuppressWarnings("SynchronizationOnLocalVariableOrMethodParameter")
  @Override
  public boolean saveEntityMessages( @javax.annotation.Nullable final String sessionID,
                                     @javax.annotation.Nullable final String requestID,
                                     @javax.annotation.Nonnull final java.util.Collection<org.realityforge.replicant.server.EntityMessage> messages,
                                     @javax.annotation.Nonnull final java.util.Collection<org.realityforge.replicant.server.EntityMessage> sessionMessages )
  {
    //TODO: Rewrite this so that we add clients to indexes rather than searching through everyone for each change!
    getLock().readLock().lock();
    final java.util.Map<String, <%= repository.imit.qualified_session_name %>> sessions = getSessions();
    final org.realityforge.replicant.server.transport.EntityMessageAccumulator accumulator = new org.realityforge.replicant.server.transport.EntityMessageAccumulator();
    try
    {
      final java.util.Collection<<%= repository.imit.qualified_session_name %>> values = sessions.values();
      for ( final org.realityforge.replicant.server.EntityMessage message : messages )
      {
        final java.util.Map<String, java.io.Serializable> routingKeys = message.getRoutingKeys();
<%
  repository.imit.graphs.each do |graph|

  param = ''
  type = 'Boolean'
  check_method = "isInterestedIn#{graph.key}"
  if graph.instance_root?
    # Names are fully qualified so take any random data module
    entity = repository.data_modules[0].entity_by_name(graph.instance_root)
    type = entity.primary_key.imit.non_primitive_java_type
    param = " #{graph.key} "
    check_method = "is#{graph.key}Interesting"
  end
%>

        final <%= type %> <%= graph.key %> = (<%= type %>) routingKeys.get( <%= repository.imit.qualified_router_impl_name %>.<%=Domgen::Naming.uppercase_constantize(graph.key)%>_KEY );
<%
  extra_interest_filter = ''
  repository.data_modules.each do |data_module|
    data_module.entities.each do |entity|
      entity.attributes.select{|a| a.imit? && a.imit.filter_in_graphs.include?(graph.key) }.each do |attribute|
        var_name = "#{graph.key}#{attribute.qualified_name.gsub('.','_')}"
        extra_interest_filter << ", #{var_name}"
%>
        final <%= attribute.imit.non_primitive_java_type %> <%= var_name %> = (<%= attribute.imit.non_primitive_java_type %>) routingKeys.get( <%= repository.imit.qualified_router_impl_name %>.<%= Domgen::Naming.uppercase_constantize(graph.key) %>_<%= Domgen::Naming.uppercase_constantize(attribute.qualified_name.gsub('.','_')) %>_KEY );
<%
      end
    end
  end

  if !extra_interest_filter.empty?
    extra_interest_filter = "&& is#{graph.key}Interesting( session#{graph.instance_root? ? ", #{graph.key}" : ''}#{extra_interest_filter} ) "
  end
%>

        if ( null != <%= graph.key %> )
        {
          for ( final <%= repository.imit.qualified_session_name %> session : values )
          {
            if ( session.<%= check_method %>(<%= param %> ) <%= extra_interest_filter %>)
            {
              accumulator.addEntityMessage( session, message );
            }
          }
        }
<% end %>
      }
      final <%= repository.imit.qualified_session_name %> session = getSession( sessionID );
      if( null != session )
      {
        accumulator.addEntityMessages( session, sessionMessages );
      }
    }
    finally
    {
      getLock().readLock().unlock();
    }

    return accumulator.complete( sessionID, requestID );
  }
<%
  repository.imit.graphs.each do |graph|
    extra_interest_filter = ''
    repository.data_modules.each do |data_module|
      data_module.entities.each do |entity|
        entity.attributes.select{|a| a.imit? && a.imit.filter_in_graphs.include?(graph.key) }.each do |attribute|
          var_name = Domgen::Naming.camelize("#{attribute.entity.name}#{attribute.name}")
          extra_interest_filter << ", #{nullability_annotation(attribute.nullable?)} #{attribute.imit.non_primitive_java_type} #{var_name}"
        end
      end
    end
  initial_param = ''
  check_method = "is#{graph.key}Interesting"
  if graph.instance_root?
    # Names are fully qualified so take any random data module
    entity = repository.data_modules[0].entity_by_name(graph.instance_root)
    type = entity.primary_key.imit.non_primitive_java_type
    initial_param = ", #{type} #{Domgen::Naming.camelize("#{entity.name}#{entity.primary_key.name}")}"
    check_method = "is#{graph.key}Interesting"
  end
  if extra_interest_filter.size > 0
%>
  protected abstract boolean <%= check_method %>( <%= repository.imit.qualified_session_name %> session<%= initial_param %><%= extra_interest_filter %> );
<%
  end
end
%>

  @javax.annotation.Nonnull
  @Override
  protected <%= repository.imit.qualified_session_name %> newSessionInfo()
  {
    return new <%= repository.imit.qualified_session_name %>( java.util.UUID.randomUUID().toString() );
  }

<%
  repository.imit.graphs.each do |graph|

  param = ''
  register_method = "setInterestedIn#{graph.key}( true )"
  deregister_method = "setInterestedIn#{graph.key}( false )"
  check_method = "isInterestedIn#{graph.key}()"
  if graph.instance_root?
    # Names are fully qualified so take any random data module
    entity = repository.data_modules[0].entity_by_name(graph.instance_root)
    param = ", @javax.annotation.Nonnull final #{entity.jpa.qualified_name} entity"
    register_method = "registerInterestIn#{graph.key}( entity.#{getter_for(entity.primary_key)} )"
    deregister_method = "deregisterInterestIn#{graph.key}( entity.#{getter_for(entity.primary_key)} )"
    check_method = "is#{graph.key}Interesting( entity.#{getter_for(entity.primary_key)} )"
  end
%>
<% if graph.cacheable? -%>
  private org.realityforge.replicant.server.EntityMessageSet _cached<%= graph.key %>Messages;
  private final java.util.concurrent.locks.ReadWriteLock _lock<%= graph.key %>Cache = new java.util.concurrent.locks.ReentrantReadWriteLock();
  private String _cached<%= graph.key %>Key;
<% end -%>

  public <%= graph.cacheable? ? "boolean" : "void" %> subscribeTo<%= graph.key %>( @javax.annotation.Nonnull final String sessionID<%= param %><% if graph.cacheable? -%>, @javax.annotation.Nullable final String cacheKey<% end %> )
  {
    final <%= repository.imit.qualified_session_name %> session = ensureSession( sessionID );
    if ( !session.<%= check_method %> )
    {
      session.<%= register_method %>;
<% if graph.instance_root? -%>
      getEncoder().encode<%= graph.key %>( org.realityforge.replicant.server.ee.EntityMessageCacheUtil.getSessionEntityMessageSet(), entity );
<% else -%>
<% if graph.cacheable? -%>
    _lock<%= graph.key %>Cache.readLock().lock();
    final String cached<%= graph.key %>Key = get<%= graph.key %>CacheKey();
    if ( null == _cachedMetaDataMessages || ( null == cached<%= graph.key %>Key || !cached<%= graph.key %>Key.equals( _cached<%= graph.key %>Key ) ) )
    {
      _lock<%= graph.key %>Cache.readLock().unlock();
      _lock<%= graph.key %>Cache.writeLock().lock();
      try
      {
        _cached<%= graph.key %>Key = cached<%= graph.key %>Key;
        _cached<%= graph.key %>Messages = new org.realityforge.replicant.server.EntityMessageSet();
        collect<%= graph.key %>( _cached<%= graph.key %>Messages );
      }
      finally
      {
        _lock<%= graph.key %>Cache.writeLock().unlock();
      }
    }
    else
    {
      _lock<%= graph.key %>Cache.readLock().unlock();
    }
<% else -%>
      collect<%= graph.key %>( org.realityforge.replicant.server.ee.EntityMessageCacheUtil.getSessionEntityMessageSet() );
<% end -%>
<% end -%>
<% if graph.cacheable? -%>
      if( null == cacheKey || !cacheKey.equals( _cached<%= graph.key %>Key ) )
      {
        final java.util.LinkedList<org.realityforge.replicant.server.EntityMessage> messages = new java.util.LinkedList<org.realityforge.replicant.server.EntityMessage>();
        messages.addAll( _cached<%= graph.key %>Messages.getEntityMessages() );
        sendPacket( session, _cached<%= graph.key %>Key, messages );
        return true;
      }
<% end -%>
    }
<% if graph.cacheable? -%>
    return false;
<% end -%>
  }

<% if !graph.instance_root? -%>
<% if graph.cacheable? -%>
  protected abstract String get<%= graph.key %>CacheKey();
<% end -%>
  protected abstract void collect<%= graph.key %>( @javax.annotation.Nonnull final org.realityforge.replicant.server.EntityMessageSet messages );
<% end -%>

  public void unsubscribeFrom<%= graph.key %>( @javax.annotation.Nonnull final String sessionID<%= param %> )
    throws org.realityforge.replicant.server.transport.BadSessionException
  {
    ensureSession( sessionID ).<%= deregister_method %>;
  }
<% end %>
}
