/* DO NOT EDIT: File is auto-generated */
package <%= to_package(data_module.sync.qualified_sync_context_impl_name) %>;

/**

 Base class to extend to customize the synchronization process.

<code>
<pre>
@Singleton( name = SynchronizationContext.NAME )
@TransactionManagement( TransactionManagementType.BEAN )
@ConcurrencyManagement( ConcurrencyManagementType.BEAN )
@Local( SynchronizationContext.class )
public class SynchronizationContextEJB
  extends AbstractSynchronizationContext
{
}
</pre>
</code>
 */
public abstract class <%= data_module.sync.sync_context_impl_name %>
  implements <%= data_module.service_by_name(:SynchronizationContext).ejb.qualified_service_name %>
{
<% data_module.sync.entities_to_synchronize.each do |entity|
     fn = "#{entity.data_module.name}#{entity.name}"
     recursive_attributes = entity.attributes.select{|a| a.reference? && a.referenced_entity.qualified_name == entity.qualified_name}

     entity.attributes.select{|a| a.sync? && a.sync.custom_transform? }.each do |attribute|
-%>
  <%= nullability_annotation(attribute.nullable?) %>
  @java.lang.Override
  public <%= attribute.jpa.java_type(:boundary) %> transform<%= fn %><%= attribute.name %>( <%= nullability_annotation(attribute.nullable?) %> final <%= attribute.jpa.java_type(:boundary) %> value )
  {
<% if attribute.sync.custom_transform? || !attribute.reference? -%>
    return value;
<% else -%>
<% if attribute.nullable? -%>
    if ( null == value )
    {
      return null;
    }
    else
    {
<% end -%>
      return (Integer) _entityManager.
        createNativeQuery( "SELECT <%= entity.sync.master_entity.attribute_by_name( attribute.primary_key? ? attribute.entity.name : attribute.name ).sql.quoted_column_name %> FROM <%= entity.sync.master_entity.sql.qualified_table_name %> WHERE <%= data_module.sql.dialect.quote('MasterID') %> = ?1" ).
        setParameter( 1, value ).
        getSingleResult();
<% if attribute.nullable? -%>
    }
<% end -%>
<% end -%>
  }

<% end -%>

  @javax.annotation.Nonnull
  protected String get<%= fn %>Columns( @javax.annotation.Nullable final String prefix )
  {
    return
<% entity.attributes.select{|a| a.sync? && a.sql? && a.jpa? }.each do |a| -%>
      ( null == prefix ? "" : prefix + "." ) + "<%= entity.sync.master_entity.attribute_by_name( a.primary_key? ? a.entity.name : a.name ).sql.quoted_column_name %>, " +
<% end -%>
      ( null == prefix ? "" : prefix + "." ) + "<%= data_module.sql.dialect.quote('MappingID') %>";
  }

  @javax.annotation.Nonnull
  protected String get<%= fn %>MasterTable()
  {
    return "<%= entity.sync.master_entity.sql.qualified_table_name %>";
  }

  @javax.annotation.Nonnull
  protected String get<%= fn %>MasterTableCriteria( @javax.annotation.Nonnull final String prefix, @javax.annotation.Nonnull final String dataSourceCode )
  {
    return prefix + ".<%= data_module.sql.dialect.quote('MasterSynchronized') %> = 0 AND " + prefix + ".<%= data_module.sql.dialect.quote('MappingSource') %> = ?";
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  public String getSqlToRetrieve<%= fn %>ListToUpdate( @javax.annotation.Nonnull final String dataSourceCode )
  {
<% if recursive_attributes.size == 0 -%>
    return
      "SELECT " + get<%= fn %>Columns( "M" ) + " " +
      "FROM " + get<%= fn %>MasterTable() + " M " +
      "WHERE " + get<%= fn %>MasterTableCriteria( "M", dataSourceCode ) + " AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL";
<% elsif recursive_attributes.size == 1 -%>
    return
      "WITH <%= fn %>List([ID], " + get<%= fn %>Columns( null ) + ", [MasterSynchronized], [MappingSource], [Level]) AS (\n" +
      "  SELECT M.[ID], " + get<%= fn %>Columns( "M" ) + ", M.[MasterSynchronized], M.[MappingSource], 0 " +
      "  FROM " + get<%= fn %>MasterTable() + " M " +
      "  WHERE M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL AND M.<%= recursive_attributes[0].sql.quoted_column_name %> IS NULL " +
      "  UNION ALL\n" +
      "  SELECT M.[ID], " + get<%= fn %>Columns( "M" ) + ", M.[MasterSynchronized], M.[MappingSource], L.[Level] + 1 " +
      "  FROM " + get<%= fn %>MasterTable() + " M " +
      "  JOIN <%= fn %>List L ON L.[ID] = M.<%= recursive_attributes[0].sql.quoted_column_name %> " +
      "  WHERE M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL " +
      " )\n " +
      " SELECT " + get<%= fn %>Columns( "R" ) +
      "  FROM <%= fn %>List R" +
      "  WHERE " + get<%= fn %>MasterTableCriteria( "R", dataSourceCode ) +
      "  ORDER BY R.Level ASC ";
<% else -%>
    /*
    return
      "SELECT " + get<%= fn %>Columns( "M" ) + " " +
      "FROM " + get<%= fn %>MasterTable() + " M " +
      "WHERE " + get<%= fn %>MasterTableCriteria( "M", dataSourceCode ) + " AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL";
    */
    throw new IllegalStateException( "Override getSqlToRetrieve<%= fn %>ListToUpdate() due to multiple recursive attributes." );
<% end -%>
  }

  @javax.annotation.Nonnull
  @java.lang.Override
  public String getSqlToRetrieve<%= fn %>ListToRemove( @javax.annotation.Nonnull final String dataSourceCode )
  {
<% if recursive_attributes.size == 0 -%>
    return
      "SELECT M.<%= data_module.sql.dialect.quote('MappingID') %>, M.<%= entity.sync.master_entity.attribute_by_name( entity.name ).sql.quoted_column_name %> " +
      "FROM " + get<%= fn %>MasterTable() + " M " +
      "WHERE " + get<%= fn %>MasterTableCriteria( "M", dataSourceCode ) + " AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NOT NULL";
<% elsif recursive_attributes.size == 1 -%>
    return
      "WITH <%= fn %>List([ID], " + get<%= fn %>Columns( null ) + ", [MasterSynchronized], [MappingSource], [Level]) AS (\n" +
      "  SELECT M.[ID], " + get<%= fn %>Columns( "M" ) + ", M.[MasterSynchronized], M.[MappingSource], 0 " +
      "  FROM " + get<%= fn %>MasterTable() + " M " +
      "  WHERE M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL AND M.<%= recursive_attributes[0].sql.quoted_column_name %> IS NULL " +
      "  UNION ALL\n" +
      "  SELECT M.[ID], " + get<%= fn %>Columns( "M" ) + ", M.[MasterSynchronized], M.[MappingSource], L.[Level] + 1 " +
      "  FROM " + get<%= fn %>MasterTable() + " M " +
      "  JOIN <%= fn %>List L ON L.[ID] = M.<%= recursive_attributes[0].sql.quoted_column_name %> " +
      "  WHERE M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NULL " +
      " )\n " +
      " SELECT R.<%= data_module.sql.dialect.quote('MappingID') %>, R.<%= entity.sync.master_entity.attribute_by_name( entity.name ).sql.quoted_column_name %> " +
      "  FROM <%= fn %>List R" +
      "  WHERE " + get<%= fn %>MasterTableCriteria( "R", dataSourceCode ) + " AND R.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NOT NULL" +
      "  ORDER BY R.Level DESC ";
<% else -%>
    /*
    return
      "SELECT M.<%= data_module.sql.dialect.quote('MappingID') %>, M.<%= entity.sync.master_entity.attribute_by_name( entity.name ).sql.quoted_column_name %> " +
      "FROM " + get<%= fn %>MasterTable() + " M " +
      "WHERE " + get<%= fn %>MasterTableCriteria( "M", dataSourceCode ) + " AND M.<%= data_module.sql.dialect.quote('DeletedAt') %> IS NOT NULL";
    */
    throw new IllegalStateException( "Override getSqlToRetrieve<%= fn %>ListToRemove() due to multiple recursive attributes." );
<% end -%>
  }

<% end -%>
}
